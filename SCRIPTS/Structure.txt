atomComplex={Quantity,Association,Dataset};

structureRule[x_]:=If[Head[x]===Rule,x[[1]],None];

structureQuantity[x_]:=If[Head[x]===Quantity,x[[2]],None];

structureAssociation[x_]:=Module[{nx},
  nx = Normal[x];
  If[Head[x]===Association,{Keys[x],Map[Head[#[[2]]]&,nx],Map[structureQuantity[#[[2]]]&,nx]},None]  ];

structureComp[x_, y_] := Module[{tx, ty}, tx = Transpose[x];
      ty = Transpose[y]; Outer[SameQ, tx, ty, 1]];

structureMatch[x_, y_] := Module[{tab, xmatch, xpos},
     tab = structureComp[x, y]; xmatch = (Flatten[Position[#1, True]] & ) /@
        tab; xpos = Flatten[Position[xmatch, {__Integer}]]; {xpos, xmatch}];

structureMatchComplete[x_,y_] := Module[{tab,xlen,ylen,d,ctab},
  tab = structureComp[x,y];
  d = Dimensions[tab];
  xlen = Length[Transpose[x]];
  ylen = Length[Transpose[y]];
  If[d=={xlen,ylen},Continue[],Return[False]];
  ctab = Table[False,{xlen},{ylen}];
  Map[(ctab[[#,#]]=True)&,Range[xlen]];
  tab==ctab
];

mlCheckMerge[x_, y_] := Module[{tx, ty, dtx, dty},
     tx = Tally[structureAssociation /@ x];
      ty = Tally[structureAssociation /@ y]; dtx = Dimensions[tx];
      dty = Dimensions[ty]; If[dtx == dty == {1, 2}, Null, Return[]];
      If[tx[[1,1]] === ty[[1,1]], Null, Return[]]; If[tx[[1,1]] == ty[[1,1]],
       Join[x, y], Return[]]];

mlCheckMergeMulti[x__] := Module[{lx, l, maptx, mapdtx, mapftx},
     lx = {x}; l = Length[lx]; maptx =
       Table[Tally[structureAssociation /@ lx[[n]]], {n, l}];
      mapdtx = Table[Dimensions[maptx[[n]]], {n, l}];
      If[Equal @@ mapdtx, mapftx = (#1[[1,1]] & ) /@ maptx, Return[]];
      If[SameQ @@ mapftx, Null, Return[]]; If[Equal @@ mapftx, Join[x],
       Return[]]];


